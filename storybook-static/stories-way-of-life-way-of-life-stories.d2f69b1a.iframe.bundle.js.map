{"version":3,"file":"stories-way-of-life-way-of-life-stories.d2f69b1a.iframe.bundle.js","mappings":";;;;AAiGA;;;AAqCA;AAQA;AACA;;AAGA","sources":["webpack://react-hexgrid/./src/stories/way-of-life/way-of-life.stories.tsx"],"sourcesContent":["import * as React from \"react\"\nimport { ComponentStory, ComponentMeta } from \"@storybook/react\"\nimport { HexGrid, Layout, Hexagon, GridGenerator, HexUtils } from \"../..\"\nimport { css } from \"@emotion/react\"\nimport { useInterval } from \"react-use\"\nimport { COLORS } from \"../colors\"\n\nexport default {\n  title: \"Way of life\",\n  component: Hexagon,\n} as ComponentMeta<typeof Hexagon>\n\ntype State = \"Dead\" | \"Living\"\n\ntype Coordinates = { q: number; r: number; s: number }\n\ntype Cell = Coordinates & { state: State }\n\ntype CellDict = { [coords: string]: Cell }\n\nfunction reset() {\n  const count = 8\n  const initialHexagons = GridGenerator.hexagon(count)\n  const dict: CellDict = {}\n  const hexas: Cell[] = initialHexagons.map(({ q, r, s }) => ({\n    ...{ q, r, s },\n    state: (Math.random() < 0.4 &&\n    HexUtils.distance({ q, r, s }, { q: 0, r: 0, s: 0 }) <= 3\n      ? \"Living\"\n      : \"Dead\") as State,\n  }))\n  hexas.forEach((hex) => {\n    const { q, r, s } = hex\n    dict[`${q}-${r}-${s}`] = hex\n  })\n  return dict\n}\n\nfunction getNeighbors(hex: Cell, dict: CellDict) {\n  let neighbors = HexUtils.neighbors(hex)\n  return neighbors\n    .map(({ q, r, s }) => dict[`${q}-${r}-${s}`])\n    .filter((v) => Boolean(v))\n}\n\nfunction countLivingNeighbors(hex: Cell, dict: CellDict) {\n  const neighbors = getNeighbors(hex, dict)\n  return neighbors.reduce((v1, v2) => v1 + (v2.state === \"Living\" ? 1 : 0), 0)\n}\n\nconst colors = [COLORS.teal]\nconst elementSize = 2.7\nconst size = { x: elementSize, y: elementSize }\n\nconst Template: ComponentStory<typeof Hexagon> = (args, { argTypes }) => {\n  const [hexagons, setHexagons] = React.useState<CellDict>({})\n  React.useEffect(() => {\n    const hexas = reset()\n    setHexagons(hexas)\n  }, [])\n  const [step, setI] = React.useState(0)\n  const [speed, setSpeed] = React.useState(20)\n  const timing = speed / 20.0\n\n  useInterval(() => {\n    const result: CellDict = {}\n    Object.keys(hexagons).forEach((coords) => {\n      const element = hexagons[coords]\n      const { q, r, s, state } = element\n      let livingNeighbors = countLivingNeighbors(element, hexagons)\n\n      if (livingNeighbors == 2) {\n        result[`${q}-${r}-${s}`] = { ...element, state: \"Living\" }\n      } else {\n        result[`${q}-${r}-${s}`] = { ...element, state: \"Dead\" }\n      }\n    })\n\n    setHexagons(result)\n    setI(step + 1)\n  }, timing * 1000)\n\n  const dyingAnimationDuration = timing * 1.5\n  const revivingAnimationDuration = timing * 0.8\n\n  const timingFunctionDying = `fill ${dyingAnimationDuration}s cubic-bezier(0.7, 0.8, 0.9, 1)`\n  const timingFunctionReviving = `fill ${revivingAnimationDuration}s cubic-bezier(0.2, 0.5, 0.9, 1)`\n\n  return (\n    <div\n      style={{ background: COLORS.gray[1] }}\n      css={css`\n        margin: 0;\n        padding: 1em;\n        font-family: sans-serif;\n      `}\n    >\n      <div>\n        <p>\n          <b>Living cells: </b>\n          Each cell with one or no neighbors dies from isolation. Each cell with\n          three or more neighbors dies from overpopulation. Only the cells with\n          two neighbors survive.\n        </p>\n        <p>\n          <b>Dead cells:</b> Each cell with two neighbors revives.\n        </p>\n      </div>\n      <div>\n        <button\n          onClick={() => {\n            const newGrid = reset()\n            setHexagons(newGrid)\n          }}\n        >\n          Reset\n        </button>{\" \"}\n        <button onClick={() => setSpeed(speed + 1)}>-</button>{\" \"}\n        <button onClick={() => setSpeed(Math.max(speed - 1, 1))}>+</button>{\" \"}\n        speed: {speed}\n      </div>\n      <HexGrid width={800} height={800} viewBox=\"-40 -40 100 100\">\n        <Layout size={size} flat={true} spacing={1}>\n          {Object.keys(hexagons)\n            .map((v) => hexagons[v])\n            .map((hex, i) => (\n              <Hexagon\n                key={i}\n                q={hex.q}\n                r={hex.r}\n                s={hex.s}\n                css={css`\n                  g {\n                    polygon {\n                      fill: ${hex.state === \"Dead\"\n                        ? COLORS.gray[\n                            HexUtils.distance(hex, { q: 0, r: 0, s: 0 }) % 4\n                          ]\n                        : colors[step % colors.length][\n                            5 +\n                              (HexUtils.distance(hex, { q: 0, r: 0, s: 0 }) % 3)\n                          ]};\n                      stroke: ${COLORS.dark[4]};\n                      stroke-opacity: ${0.6 /\n                      HexUtils.distance(hex, { q: 0, r: 0, s: 0 })};\n                      stroke-width: 0.15;\n                      transition: ${hex.state === \"Dead\"\n                        ? timingFunctionDying\n                        : timingFunctionReviving};\n                    }\n                  }\n                `}\n              />\n            ))}\n        </Layout>\n      </HexGrid>\n    </div>\n  )\n}\n\nexport const Default = Template.bind({})\n"],"names":[],"sourceRoot":""}